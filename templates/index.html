<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwoleMate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>

    <style>
        body {
            font-family: 'Poppins', sans-serif;
        }

        #sidebar {
            height: 100%;
            width: 220px;
            position: fixed;
            top: 0;
            left: 0;
            background-color: #1a1a2e;
            padding-top: 20px;
            color: white;
            box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1);
        }

        #sidebar h2 {
            padding-left: 10px;
            font-size: 1.5rem;
            font-weight: 600;
            padding-top: 10px;
        }

        #sidebar a {
            padding: 25px 35px;
            text-decoration: none;
            font-size: 1.125rem;
            color: white;
            display: block;
            transition: background-color 0.3s ease;
        }

        #sidebar a:hover {
            background-color: #575757;
        }

        #mainWrapper {
            margin-left: 240px;
        }

        .bg-main-gradient {
            background-color:#f7f2eb;
        }

        .btn {
            font-weight: 600;
            padding: 12px 24px;
            border-radius: 8px;
            transition: transform 0.3s ease, background-color 0.3s ease;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        #videoContainer {
            position: relative;
            width: 640px;
            height: 480px;
            margin: 20px 0;
        }

        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
            object-fit: cover;
        }

        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
        }

        #analysisResults {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background-color: #1a1a2e;
            border-radius: 8px;
            color: white;
        }

        #resultsList {
            margin-top: 10px;
        }

        .result-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: #2c2c54;
            border-radius: 8px;
        }
    </style>
</head>
<body class="bg-main-gradient text-white">
    <div id="sidebar" class="p-6">
        <h2>SwoleMate</h2>
        <a href="#">Profile</a>
        <a href="#">Rewards</a>
        <a href="#" id="openChatButton">Chat</a>
    </div>

    <div id="mainWrapper" class="p-8">
        <div id="mainContent" class="space-y-6">
            <h1 class="text-4xl font-extrabold text-[#1a1a2e]">Welcome to SwoleMate</h1>

            <div id="videoContainer" class="rounded-lg shadow-lg overflow-hidden">
                <video id="videoElement" autoplay playsinline></video>
                <canvas id="output_canvas"></canvas>
            </div>

            <!-- Coordinate Table -->
            <div class="overflow-x-auto mt-4">
                <table id="coordinateTable" class="min-w-full bg-white rounded-lg overflow-hidden shadow-lg">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600">Frame</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Left Shoulder</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Right Shoulder</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Left Elbow</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Right Elbow</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Left Wrist</th>
                            <th class="px-4 py-2 text-left text-sm font-semibold text-gray-600" colspan="3">Right Wrist</th>
                        </tr>
                        <tr>
                            <th class="px-4 py-2"></th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">X</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Y</th>
                            <th class="px-4 py-2 text-left text-xs font-semibold text-gray-500">Z</th>
                        </tr>
                    </thead>
                    <tbody id="coordinateTableBody">
                    </tbody>
                </table>
            </div>


            <div class="flex space-x-4">
                <button id="startButton" class="bg-green-500 text-white btn">Start Recording</button>
                <button id="stopButton" disabled class="bg-red-500 text-white btn">Stop Recording</button>
                <button id="saveButton" disabled class="bg-blue-500 text-white btn">Save Recording</button>
            </div>

            <div>
                <h3 class="text-lg font-semibold text-[#1a1a2e]">Choose an exercise:</h3>
                <select id="exerciseSelect" class="bg-gray-800 border-2 border-gray-600 text-white p-3 rounded-lg shadow-md">
                    <option value="shoulder_press">Shoulder Press</option>
                    <option value="squats">Squats</option>
                </select>
            </div>

            <div id="analysisResults">
                <h3 class="text-lg font-semibold">Analysis Results</h3>
                <div id="resultsList"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            PoseLandmarker,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const saveButton = document.getElementById('saveButton');
        const resultsList = document.getElementById('resultsList');
        const analysisResults = document.getElementById('analysisResults');

        let poseLandmarker = null;
        let runningMode = "VIDEO";
        let webcamRunning = true;
        let mediaRecorder = null;
        let recordedChunks = [];
        let frameCount = 0;
        let isRecording = false; // Add this to control table updates
        const maxFrames = 10;

        // Initialize pose landmarker
        const createPoseLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numPoses: 2
            });
        };

        await createPoseLandmarker();
        const drawingUtils = new DrawingUtils(canvasCtx);

        // Function to update canvas size
        function updateCanvasSize() {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
        }

        // Set up webcam
        navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 }
            }
        })
        .then(stream => {
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                updateCanvasSize();
                predictWebcam(); // Start pose detection immediately
            };

            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = function() {
                const blob = new Blob(recordedChunks, { type: 'video/mp4' });
                const videoURL = URL.createObjectURL(blob);
                console.log("Recording complete. Video URL:", videoURL);

                const formData = new FormData();
                formData.append('video', blob, 'recorded_video.mp4');

                fetch('/upload_video', {
                    method: 'POST',
                    body: formData
                })
                .then(response => {
                    if (!response.ok) throw new Error('Failed to upload video');
                    return response.json();
                })
                .then(data => {
                    resultsList.innerHTML = ''; // Clear previous results

                    if (data.error) {
                        resultsList.innerHTML = `<p class="text-red-500">${data.error}</p>`;
                    } else {
                        data.results.forEach(result => {
                            const resultItem = document.createElement('div');
                            resultItem.className = 'result-item';
                            resultItem.innerHTML = `
                                <p class="font-semibold">${result.message}</p>
                                <p class="text-sm">Confidence: ${(result.confidence * 100).toFixed(2)}%</p>
                            `;
                            resultsList.appendChild(resultItem);
                        });
                    }

                    // Show the results container
                    analysisResults.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error:', error);
                    resultsList.innerHTML = `<p class="text-red-500">Failed to analyze video. Please try again.</p>`;
                    analysisResults.style.display = 'block';
                });
            };
        })
        .catch(err => console.error('Error accessing camera:', err));

        // Recording controls
        startButton.addEventListener('click', () => {
            recordedChunks = [];
            mediaRecorder.start();
            startButton.disabled = true;
            stopButton.disabled = false;
            saveButton.disabled = false;

            document.getElementById('coordinateTableBody').innerHTML = '';
            frameCount = 0;
            webcamRunning = true;
            isRecording = true; // Start table updates
        });

        stopButton.addEventListener('click', () => {
            mediaRecorder.stop();
            startButton.disabled = false;
            stopButton.disabled = true;
            isRecording = false;
        });

        saveButton.addEventListener('click', () => {
            mediaRecorder.stop();
            isRecording = false;
        });

        // Pose detection
        let lastVideoTime = -1;
        async function predictWebcam() {
            if (!poseLandmarker) return;

            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await poseLandmarker.setOptions({ runningMode: "VIDEO" });
            }
            let startTimeMs = performance.now();

            if (lastVideoTime !== videoElement.currentTime) {
                lastVideoTime = videoElement.currentTime;
                poseLandmarker.detectForVideo(videoElement, startTimeMs, (result) => {
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    if (result.landmarks && result.landmarks[0] && isRecording) {
                        const landmarks = result.landmarks[0];
                        
                        // Get table body reference
                        const tableBody = document.getElementById('coordinateTableBody');
                        
                        // Create new row
                        const row = document.createElement('tr');
                        row.className = frameCount % 2 === 0 ? 'bg-gray-50' : 'bg-white';
                        
                        // Add frame number
                        const frameCell = document.createElement('td');
                        frameCell.className = 'px-4 py-2 text-sm text-gray-600';
                        frameCell.textContent = frameCount + 1;
                        row.appendChild(frameCell);
                        
                        // Joint indices in MediaPipe
                        const joints = [
                            landmarks[11], // Left shoulder
                            landmarks[12], // Right shoulder
                            landmarks[13], // Left elbow
                            landmarks[14], // Right elbow
                            landmarks[15], // Left wrist
                            landmarks[16]  // Right wrist
                        ];
                        
                        // Add coordinates for each joint
                        joints.forEach(joint => {
                            ['x', 'y', 'z'].forEach(coord => {
                                const cell = document.createElement('td');
                                cell.className = 'px-4 py-2 text-sm text-gray-600';
                                cell.textContent = joint[coord].toFixed(3);
                                row.appendChild(cell);
                            });
                        });
                        
                        // Add row to table
                        tableBody.insertBefore(row, tableBody.firstChild);
                        
                        // Remove old rows if we exceed maxFrames
                        if (tableBody.children.length > maxFrames) {
                            tableBody.removeChild(tableBody.lastChild);
                        }
                        
                        frameCount++;
                    }
                    for (const landmark of result.landmarks) {
                        drawingUtils.drawLandmarks(landmark, {
                            radius: (data) => DrawingUtils.lerp(data.from?.z, -0.15, 0.1, 5, 1)
                        });
                        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
                    }
                    canvasCtx.restore();
                });
            }

            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        // Handle window resize
        window.addEventListener('resize', updateCanvasSize);

        // Exercise selection
        const exerciseSelect = document.getElementById('exerciseSelect');
        exerciseSelect.addEventListener('change', function() {
            console.log('Selected exercise: ' + exerciseSelect.value);
        });
    </script>
</body>
</html>
